package com.xk.cd.ui.base.viewmodel

import android.os.Bundle
import androidx.lifecycle.*
import androidx.navigation.NavDirections
import com.xk.cd.common.helpers.NetworkHelper
import com.xk.cd.data.base.callback.ClearableCallback
import com.xk.cd.data.base.error.*
import com.xk.cd.data.base.error.APIError.ReasonOfError.NETWORK_ERROR
import com.xk.cd.data.base.error.APIError.ReasonOfError.SERVER_ERROR
import com.xk.cd.ui.base.NavigationCommand
import kotlinx.coroutines.*
import java.net.ConnectException
import java.net.SocketTimeoutException
import java.net.UnknownHostException
import java.util.*
import javax.inject.Inject

abstract class BaseViewModel : ViewModel(), LifecycleObserver {

    @Inject
    lateinit var networkHelper: NetworkHelper

    /**
     * [_coroutineExceptionHandler] context element is used as generic catch block of coroutine.
     */
    private var _coroutineExceptionHandler = CoroutineExceptionHandler { _, exception ->
        if (exception is AppException) defaultErrorHandler(exception)
        else throw exception
    }

    private val clearableCallbacks = ArrayList<ClearableCallback>()

    private val _navigationCommands = SingleLiveEvent<NavigationCommand>()
    val navigationCommands: LiveData<NavigationCommand>
        get() = _navigationCommands

    private val _loading = SingleLiveEvent<Boolean>()
    val isLoading: LiveData<Boolean>
        get() = _loading

    private val _error = MutableLiveData<BaseError?>()
    val error: LiveData<BaseError?>
        get() = _error

    val closeApplication = SingleLiveEvent<Boolean>()

    /**
     * This is the scope all coroutines should be started with.
     * This scope is bound to Dispatchers.Main
     */
    protected val viewModelScope: CoroutineScope by lazy {
        CoroutineScope(Dispatchers.Main + SupervisorJob(null))
    }

    protected open var isAnalyticsSupported = false

    /**
     * Arguments passed by originating destination.
     * Access data by using one of the static methods generated by the safe args gradle plugin
     */
    var arguments: Bundle = Bundle()

    /**
     * Ensures that all added clearable callbacks are properly disposed.
     * Ensures all started coroutines are canceled.
     * Make sure to call super due to this!
     */
    override fun onCleared() {
        super.onCleared()
        viewModelScope.cancel()
        for (clearableCallback in clearableCallbacks) {
            clearableCallback.clear()
        }
    }

    /**
     * Called by lifecycle owner when it's in [Lifecycle.State.RESUMED] state.
     * In particular case called after [BaseFragment.postInflate]
     */
    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
    open fun onLifecycleOwnerResume() {
    }

    /**
     * Called by lifecycle owner right before [Lifecycle.State.DESTROYED] state
     */
    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    open fun onLifecycleOwnerPause() {
    }

    fun isLoading(isLoading: Boolean) {
        _loading.postValue(isLoading)
    }

    protected fun addClearableCallback(clearableCallback: ClearableCallback) {
        clearableCallbacks.add(clearableCallback)
    }

    protected fun navigate(directions: NavDirections) {
        _navigationCommands.postValue(NavigationCommand.To(directions))
    }

    protected fun navigate(navCommand: NavigationCommand) {
        when (navCommand) {
            is NavigationCommand.To -> _navigationCommands.postValue(NavigationCommand.To(navCommand.directions))
            is NavigationCommand.BackTo -> _navigationCommands.postValue(
                NavigationCommand.BackTo(
                    navCommand.directions
                )
            )
            else -> _navigationCommands.postValue(navCommand)
        }
    }

    protected fun setError(error: BaseError?) {
        _error.postValue(error)
    }

    protected fun setErrorHandler(handler: (AppException) -> Unit) {
        _coroutineExceptionHandler = CoroutineExceptionHandler { _, exception ->
            if (exception is AppException) handler(exception)
            else throw exception
        }
    }

    protected fun defaultErrorHandler(exception: AppException) {
        when (exception.error.reason) {
            NETWORK_ERROR -> _error.postValue(NetworkError)
            SERVER_ERROR -> _error.postValue(ServerError)
            else -> _error.postValue(DefaultError)
        }
    }

    protected fun launch(block: suspend CoroutineScope.() -> Unit) {
        if (::networkHelper.isInitialized && !networkHelper.hasInternetConnection()) {
            _error.value = NetworkError
            return
        }
        viewModelScope.launch(_coroutineExceptionHandler) {
            try {
                block()
            } catch (e: Exception) {
                when (e) {
                    is UnknownHostException, is ConnectException ->
                        _coroutineExceptionHandler.handleException(
                            this.coroutineContext,
                            AppException(APIError(NETWORK_ERROR))
                        )
                    is AppException -> _coroutineExceptionHandler.handleException(
                        this.coroutineContext,
                        e
                    )
                    is SocketTimeoutException ->
                        _coroutineExceptionHandler.handleException(
                            coroutineContext,
                            AppException(APIError(SERVER_ERROR))
                        )
                    else ->
                        throw e
                }
            } finally {
                isLoading(false)
            }
        }
    }

    protected fun <T : ClearableCallback> T.asClearable(): T {
        addClearableCallback(this)
        return this
    }
}
